Example Simulations:
Every cell has a state, a set of neighbors, and rules regarding those neighbors which determine the cell's state in the next step. Differences the number of possible states, the construction of the grid (wrapping around the edges vs infinite grid), and what each cell state keeps track of - in the predator pray simulation, the sharks and the fish are not only their own state, but keep track of energy units. Obviously the rules are different for each simulation.

High-Level Design:
1. Every type of state/cell will inherit a Cells.Cell abstract class that will have an abstract update() method. Each specific implementation of this abstract class will then implement the simulation-specific rules.
2. In the abstract Cells.Cell class, we will have a method to access another Cells.Cell. Each cell will keep track of currentState and nextState, and the update() method described above will use currentState to determine the nextState. That way there are no concurrency issues with the states.
3. Grid will have access to all the cells in the simulation. The Grid class will be stepping through the simulation, calling update() on each cell to calculate what the next step displays. It will update each cell by looping through all of the cells contained and calling their update methods by passing in the appropriate neighboring cells. Therefore, it is up to the Grid class to determine the neighbors of each cell. This design makes sense because the Grid has access to the positions of the cells, but the cells don't know their own position on the grid. For example, a cell on the left edge of the grid will not be able to access its "left neighbor", and the Grid will contain the logic to deal with these kinds of cases. 
4. Configuration should have to seed, all the possible cell states, and then the rules for state. Additionally, it could include how to display each cell (burning trees should be red, green should be green), how the grid works on the edges (wrapping vs infinite grid), and what counts as a "neighbor" (for example, diagonal cells may not count as neighbors).
5. The GUI can display the state changes concurrently with the updates() since we keep track of previous and next state. When a cell updates itself, it will modify its next state value. The GUI will display the cell according to its next state value, but when the next call calls update, it will access the first cell's previous state to determine its own next state. At the end of the GUI's displaying for the whole step, we will reset the previous and next state for each cell accordingly.
